5b139718e831152d112494461d9bfb01
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var stringifySafe = require('../Utilities/stringifySafe').default;
var invariant = require('invariant');
function processTransform(transform) {
  if (typeof transform === 'string') {
    var regex = new RegExp(/(\w+)\(([^)]+)\)/g);
    var transformArray = [];
    var matches;
    while (matches = regex.exec(transform)) {
      var _getKeyAndValueFromCS = _getKeyAndValueFromCSSTransform(matches[1], matches[2]),
        _key = _getKeyAndValueFromCS.key,
        value = _getKeyAndValueFromCS.value;
      if (value !== undefined) {
        transformArray.push((0, _defineProperty2.default)({}, _key, value));
      }
    }
    transform = transformArray;
  }
  if (__DEV__) {
    _validateTransforms(transform);
  }
  return transform;
}
var _getKeyAndValueFromCSSTransform = function _getKeyAndValueFromCSSTransform(key, args) {
  var _args$match;
  var argsWithUnitsRegex = new RegExp(/([+-]?\d+(\.\d+)?)([a-zA-Z]+)?/g);
  switch (key) {
    case 'matrix':
      return {
        key: key,
        value: (_args$match = args.match(/[+-]?\d+(\.\d+)?/g)) == null ? void 0 : _args$match.map(Number)
      };
    case 'translate':
    case 'translate3d':
      var parsedArgs = [];
      var missingUnitOfMeasurement = false;
      var matches;
      while (matches = argsWithUnitsRegex.exec(args)) {
        var _value = Number(matches[1]);
        var _unitOfMeasurement = matches[3];
        if (_value !== 0 && !_unitOfMeasurement) {
          missingUnitOfMeasurement = true;
        }
        parsedArgs.push(_value);
      }
      if (__DEV__) {
        invariant(!missingUnitOfMeasurement, `Transform with key ${key} must have units unless the provided value is 0, found %s`, `${key}(${args})`);
        if (key === 'translate') {
          invariant((parsedArgs == null ? void 0 : parsedArgs.length) === 1 || (parsedArgs == null ? void 0 : parsedArgs.length) === 2, 'Transform with key translate must be an string with 1 or 2 parameters, found %s: %s', parsedArgs == null ? void 0 : parsedArgs.length, `${key}(${args})`);
        } else {
          invariant((parsedArgs == null ? void 0 : parsedArgs.length) === 3, 'Transform with key translate3d must be an string with 3 parameters, found %s: %s', parsedArgs == null ? void 0 : parsedArgs.length, `${key}(${args})`);
        }
      }
      if ((parsedArgs == null ? void 0 : parsedArgs.length) === 1) {
        parsedArgs.push(0);
      }
      return {
        key: 'translate',
        value: parsedArgs
      };
    case 'translateX':
    case 'translateY':
    case 'perspective':
      var argMatches = argsWithUnitsRegex.exec(args);
      if (!(argMatches != null && argMatches.length)) {
        return {
          key: key,
          value: undefined
        };
      }
      var value = Number(argMatches[1]);
      var unitOfMeasurement = argMatches[3];
      if (__DEV__) {
        invariant(value === 0 || unitOfMeasurement, `Transform with key ${key} must have units unless the provided value is 0, found %s`, `${key}(${args})`);
      }
      return {
        key: key,
        value: value
      };
    default:
      return {
        key: key,
        value: !isNaN(args) ? Number(args) : args
      };
  }
};
function _validateTransforms(transform) {
  transform.forEach(function (transformation) {
    var keys = Object.keys(transformation);
    invariant(keys.length === 1, 'You must specify exactly one property per transform object. Passed properties: %s', stringifySafe(transformation));
    var key = keys[0];
    var value = transformation[key];
    _validateTransform(key, value, transformation);
  });
}
function _validateTransform(key, value, transformation) {
  invariant(!value.getValue, 'You passed an Animated.Value to a normal component. ' + 'You need to wrap that component in an Animated. For example, ' + 'replace <View /> by <Animated.View />.');
  var multivalueTransforms = ['matrix', 'translate'];
  if (multivalueTransforms.indexOf(key) !== -1) {
    invariant(Array.isArray(value), 'Transform with key of %s must have an array as the value: %s', key, stringifySafe(transformation));
  }
  switch (key) {
    case 'matrix':
      invariant(value.length === 9 || value.length === 16, 'Matrix transform must have a length of 9 (2d) or 16 (3d). ' + 'Provided matrix has a length of %s: %s', value.length, stringifySafe(transformation));
      break;
    case 'translate':
      invariant(value.length === 2 || value.length === 3, 'Transform with key translate must be an array of length 2 or 3, found %s: %s', value.length, stringifySafe(transformation));
      break;
    case 'rotateX':
    case 'rotateY':
    case 'rotateZ':
    case 'rotate':
    case 'skewX':
    case 'skewY':
      invariant(typeof value === 'string', 'Transform with key of "%s" must be a string: %s', key, stringifySafe(transformation));
      invariant(value.indexOf('deg') > -1 || value.indexOf('rad') > -1, 'Rotate transform must be expressed in degrees (deg) or radians ' + '(rad): %s', stringifySafe(transformation));
      break;
    case 'perspective':
      invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
      invariant(value !== 0, 'Transform with key of "%s" cannot be zero: %s', key, stringifySafe(transformation));
      break;
    case 'translateX':
    case 'translateY':
    case 'scale':
    case 'scaleX':
    case 'scaleY':
      invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
      break;
    default:
      invariant(false, 'Invalid transform %s: %s', key, stringifySafe(transformation));
  }
}
module.exports = processTransform;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJzdHJpbmdpZnlTYWZlIiwiZGVmYXVsdCIsImludmFyaWFudCIsInByb2Nlc3NUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJyZWdleCIsIlJlZ0V4cCIsInRyYW5zZm9ybUFycmF5IiwibWF0Y2hlcyIsImV4ZWMiLCJfZ2V0S2V5QW5kVmFsdWVGcm9tQ1MiLCJfZ2V0S2V5QW5kVmFsdWVGcm9tQ1NTVHJhbnNmb3JtIiwia2V5IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJwdXNoIiwiX19ERVZfXyIsIl92YWxpZGF0ZVRyYW5zZm9ybXMiLCJhcmdzIiwiX2FyZ3MkbWF0Y2giLCJhcmdzV2l0aFVuaXRzUmVnZXgiLCJtYXRjaCIsIm1hcCIsIk51bWJlciIsInBhcnNlZEFyZ3MiLCJtaXNzaW5nVW5pdE9mTWVhc3VyZW1lbnQiLCJ1bml0T2ZNZWFzdXJlbWVudCIsImxlbmd0aCIsImFyZ01hdGNoZXMiLCJpc05hTiIsImZvckVhY2giLCJ0cmFuc2Zvcm1hdGlvbiIsImtleXMiLCJPYmplY3QiLCJfdmFsaWRhdGVUcmFuc2Zvcm0iLCJnZXRWYWx1ZSIsIm11bHRpdmFsdWVUcmFuc2Zvcm1zIiwiaW5kZXhPZiIsIkFycmF5IiwiaXNBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJwcm9jZXNzVHJhbnNmb3JtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZm9ybWF0XG4gKiBAZmxvd1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3RyaW5naWZ5U2FmZSA9IHJlcXVpcmUoJy4uL1V0aWxpdGllcy9zdHJpbmdpZnlTYWZlJykuZGVmYXVsdDtcbmNvbnN0IGludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdHJhbnNmb3JtIG1hdHJpeCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdHJhbnNmb3JtcywgYW5kIHVzZSB0aGF0XG4gKiB3aXRoaW4gdGhlIHN0eWxlIG9iamVjdCBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgYWxsb3dzIHVzIHRvIHByb3ZpZGUgYW4gQVBJIHRoYXQgaXMgc2ltaWxhciB0byBDU1MsIHdoZXJlIHRyYW5zZm9ybXMgbWF5XG4gKiBiZSBhcHBsaWVkIGluIGFuIGFyYml0cmFyeSBvcmRlciwgYW5kIHlldCBoYXZlIGEgdW5pdmVyc2FsLCBzaW5ndWxhclxuICogaW50ZXJmYWNlIHRvIG5hdGl2ZSBjb2RlLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzVHJhbnNmb3JtKFxuICB0cmFuc2Zvcm06IEFycmF5PE9iamVjdD4gfCBzdHJpbmcsXG4pOiBBcnJheTxPYmplY3Q+IHwgQXJyYXk8bnVtYmVyPiB7XG4gIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgvKFxcdyspXFwoKFteKV0rKVxcKS9nKTtcbiAgICBsZXQgdHJhbnNmb3JtQXJyYXk6IEFycmF5PE9iamVjdD4gPSBbXTtcbiAgICBsZXQgbWF0Y2hlcztcblxuICAgIHdoaWxlICgobWF0Y2hlcyA9IHJlZ2V4LmV4ZWModHJhbnNmb3JtKSkpIHtcbiAgICAgIGNvbnN0IHtrZXksIHZhbHVlfSA9IF9nZXRLZXlBbmRWYWx1ZUZyb21DU1NUcmFuc2Zvcm0oXG4gICAgICAgIG1hdGNoZXNbMV0sXG4gICAgICAgIG1hdGNoZXNbMl0sXG4gICAgICApO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cmFuc2Zvcm1BcnJheS5wdXNoKHtba2V5XTogdmFsdWV9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtQXJyYXk7XG4gIH1cblxuICBpZiAoX19ERVZfXykge1xuICAgIF92YWxpZGF0ZVRyYW5zZm9ybXModHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmNvbnN0IF9nZXRLZXlBbmRWYWx1ZUZyb21DU1NUcmFuc2Zvcm06IChcbiAga2V5OlxuICAgIHwgc3RyaW5nXG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwnbWF0cml4Jz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdwZXJzcGVjdGl2ZSc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwncm90YXRlJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdyb3RhdGVYJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdyb3RhdGVZJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdyb3RhdGVaJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdzY2FsZSc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwnc2NhbGVYJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdzY2FsZVknPlxuICAgIHwgJFRFTVBPUkFSWSRzdHJpbmc8J3NrZXdYJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdza2V3WSc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwndHJhbnNsYXRlJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCd0cmFuc2xhdGUzZCc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwndHJhbnNsYXRlWCc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwndHJhbnNsYXRlWSc+LFxuICBhcmdzOiBzdHJpbmcsXG4pID0+IHtrZXk6IHN0cmluZywgdmFsdWU/OiBudW1iZXJbXSB8IG51bWJlciB8IHN0cmluZ30gPSAoa2V5LCBhcmdzKSA9PiB7XG4gIGNvbnN0IGFyZ3NXaXRoVW5pdHNSZWdleCA9IG5ldyBSZWdFeHAoLyhbKy1dP1xcZCsoXFwuXFxkKyk/KShbYS16QS1aXSspPy9nKTtcblxuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICByZXR1cm4ge2tleSwgdmFsdWU6IGFyZ3MubWF0Y2goL1srLV0/XFxkKyhcXC5cXGQrKT8vZyk/Lm1hcChOdW1iZXIpfTtcbiAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgIGNhc2UgJ3RyYW5zbGF0ZTNkJzpcbiAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBbXTtcbiAgICAgIGxldCBtaXNzaW5nVW5pdE9mTWVhc3VyZW1lbnQgPSBmYWxzZTtcblxuICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICB3aGlsZSAoKG1hdGNoZXMgPSBhcmdzV2l0aFVuaXRzUmVnZXguZXhlYyhhcmdzKSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIobWF0Y2hlc1sxXSk7XG4gICAgICAgIGNvbnN0IHVuaXRPZk1lYXN1cmVtZW50ID0gbWF0Y2hlc1szXTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IDAgJiYgIXVuaXRPZk1lYXN1cmVtZW50KSB7XG4gICAgICAgICAgbWlzc2luZ1VuaXRPZk1lYXN1cmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZEFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAhbWlzc2luZ1VuaXRPZk1lYXN1cmVtZW50LFxuICAgICAgICAgIGBUcmFuc2Zvcm0gd2l0aCBrZXkgJHtrZXl9IG11c3QgaGF2ZSB1bml0cyB1bmxlc3MgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIDAsIGZvdW5kICVzYCxcbiAgICAgICAgICBgJHtrZXl9KCR7YXJnc30pYCxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAndHJhbnNsYXRlJykge1xuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIHBhcnNlZEFyZ3M/Lmxlbmd0aCA9PT0gMSB8fCBwYXJzZWRBcmdzPy5sZW5ndGggPT09IDIsXG4gICAgICAgICAgICAnVHJhbnNmb3JtIHdpdGgga2V5IHRyYW5zbGF0ZSBtdXN0IGJlIGFuIHN0cmluZyB3aXRoIDEgb3IgMiBwYXJhbWV0ZXJzLCBmb3VuZCAlczogJXMnLFxuICAgICAgICAgICAgcGFyc2VkQXJncz8ubGVuZ3RoLFxuICAgICAgICAgICAgYCR7a2V5fSgke2FyZ3N9KWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBwYXJzZWRBcmdzPy5sZW5ndGggPT09IDMsXG4gICAgICAgICAgICAnVHJhbnNmb3JtIHdpdGgga2V5IHRyYW5zbGF0ZTNkIG11c3QgYmUgYW4gc3RyaW5nIHdpdGggMyBwYXJhbWV0ZXJzLCBmb3VuZCAlczogJXMnLFxuICAgICAgICAgICAgcGFyc2VkQXJncz8ubGVuZ3RoLFxuICAgICAgICAgICAgYCR7a2V5fSgke2FyZ3N9KWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VkQXJncz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhcnNlZEFyZ3MucHVzaCgwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtrZXk6ICd0cmFuc2xhdGUnLCB2YWx1ZTogcGFyc2VkQXJnc307XG4gICAgY2FzZSAndHJhbnNsYXRlWCc6XG4gICAgY2FzZSAndHJhbnNsYXRlWSc6XG4gICAgY2FzZSAncGVyc3BlY3RpdmUnOlxuICAgICAgY29uc3QgYXJnTWF0Y2hlcyA9IGFyZ3NXaXRoVW5pdHNSZWdleC5leGVjKGFyZ3MpO1xuXG4gICAgICBpZiAoIWFyZ01hdGNoZXM/Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge2tleSwgdmFsdWU6IHVuZGVmaW5lZH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKGFyZ01hdGNoZXNbMV0pO1xuICAgICAgY29uc3QgdW5pdE9mTWVhc3VyZW1lbnQgPSBhcmdNYXRjaGVzWzNdO1xuXG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgdmFsdWUgPT09IDAgfHwgdW5pdE9mTWVhc3VyZW1lbnQsXG4gICAgICAgICAgYFRyYW5zZm9ybSB3aXRoIGtleSAke2tleX0gbXVzdCBoYXZlIHVuaXRzIHVubGVzcyB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgMCwgZm91bmQgJXNgLFxuICAgICAgICAgIGAke2tleX0oJHthcmdzfSlgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge2tleSwgdmFsdWV9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7a2V5LCB2YWx1ZTogIWlzTmFOKGFyZ3MpID8gTnVtYmVyKGFyZ3MpIDogYXJnc307XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF92YWxpZGF0ZVRyYW5zZm9ybXModHJhbnNmb3JtOiBBcnJheTxPYmplY3Q+KTogdm9pZCB7XG4gIHRyYW5zZm9ybS5mb3JFYWNoKHRyYW5zZm9ybWF0aW9uID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModHJhbnNmb3JtYXRpb24pO1xuICAgIGludmFyaWFudChcbiAgICAgIGtleXMubGVuZ3RoID09PSAxLFxuICAgICAgJ1lvdSBtdXN0IHNwZWNpZnkgZXhhY3RseSBvbmUgcHJvcGVydHkgcGVyIHRyYW5zZm9ybSBvYmplY3QuIFBhc3NlZCBwcm9wZXJ0aWVzOiAlcycsXG4gICAgICBzdHJpbmdpZnlTYWZlKHRyYW5zZm9ybWF0aW9uKSxcbiAgICApO1xuICAgIGNvbnN0IGtleSA9IGtleXNbMF07XG4gICAgY29uc3QgdmFsdWUgPSB0cmFuc2Zvcm1hdGlvbltrZXldO1xuICAgIF92YWxpZGF0ZVRyYW5zZm9ybShrZXksIHZhbHVlLCB0cmFuc2Zvcm1hdGlvbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBfdmFsaWRhdGVUcmFuc2Zvcm0oXG4gIGtleTpcbiAgICB8IHN0cmluZ1xuICAgIHwgJFRFTVBPUkFSWSRzdHJpbmc8J21hdHJpeCc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwncGVyc3BlY3RpdmUnPlxuICAgIHwgJFRFTVBPUkFSWSRzdHJpbmc8J3JvdGF0ZSc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwncm90YXRlWCc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwncm90YXRlWSc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwncm90YXRlWic+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwnc2NhbGUnPlxuICAgIHwgJFRFTVBPUkFSWSRzdHJpbmc8J3NjYWxlWCc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwnc2NhbGVZJz5cbiAgICB8ICRURU1QT1JBUlkkc3RyaW5nPCdza2V3WCc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwnc2tld1knPlxuICAgIHwgJFRFTVBPUkFSWSRzdHJpbmc8J3RyYW5zbGF0ZSc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwndHJhbnNsYXRlWCc+XG4gICAgfCAkVEVNUE9SQVJZJHN0cmluZzwndHJhbnNsYXRlWSc+LFxuICB2YWx1ZTogYW55IHwgbnVtYmVyIHwgc3RyaW5nLFxuICB0cmFuc2Zvcm1hdGlvbjogYW55LFxuKSB7XG4gIGludmFyaWFudChcbiAgICAhdmFsdWUuZ2V0VmFsdWUsXG4gICAgJ1lvdSBwYXNzZWQgYW4gQW5pbWF0ZWQuVmFsdWUgdG8gYSBub3JtYWwgY29tcG9uZW50LiAnICtcbiAgICAgICdZb3UgbmVlZCB0byB3cmFwIHRoYXQgY29tcG9uZW50IGluIGFuIEFuaW1hdGVkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAncmVwbGFjZSA8VmlldyAvPiBieSA8QW5pbWF0ZWQuVmlldyAvPi4nLFxuICApO1xuXG4gIGNvbnN0IG11bHRpdmFsdWVUcmFuc2Zvcm1zID0gWydtYXRyaXgnLCAndHJhbnNsYXRlJ107XG4gIGlmIChtdWx0aXZhbHVlVHJhbnNmb3Jtcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSksXG4gICAgICAnVHJhbnNmb3JtIHdpdGgga2V5IG9mICVzIG11c3QgaGF2ZSBhbiBhcnJheSBhcyB0aGUgdmFsdWU6ICVzJyxcbiAgICAgIGtleSxcbiAgICAgIHN0cmluZ2lmeVNhZmUodHJhbnNmb3JtYXRpb24pLFxuICAgICk7XG4gIH1cbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgaW52YXJpYW50KFxuICAgICAgICB2YWx1ZS5sZW5ndGggPT09IDkgfHwgdmFsdWUubGVuZ3RoID09PSAxNixcbiAgICAgICAgJ01hdHJpeCB0cmFuc2Zvcm0gbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDkgKDJkKSBvciAxNiAoM2QpLiAnICtcbiAgICAgICAgICAnUHJvdmlkZWQgbWF0cml4IGhhcyBhIGxlbmd0aCBvZiAlczogJXMnLFxuICAgICAgICAvKiAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gKD49MC44NC4wIHNpdGU9cmVhY3RfbmF0aXZlX2ZiKSBUaGlzXG4gICAgICAgICAqIGNvbW1lbnQgc3VwcHJlc3NlcyBhbiBlcnJvciBmb3VuZCB3aGVuIEZsb3cgdjAuODQgd2FzIGRlcGxveWVkLiBUb1xuICAgICAgICAgKiBzZWUgdGhlIGVycm9yLCBkZWxldGUgdGhpcyBjb21tZW50IGFuZCBydW4gRmxvdy4gKi9cbiAgICAgICAgdmFsdWUubGVuZ3RoLFxuICAgICAgICBzdHJpbmdpZnlTYWZlKHRyYW5zZm9ybWF0aW9uKSxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgaW52YXJpYW50KFxuICAgICAgICB2YWx1ZS5sZW5ndGggPT09IDIgfHwgdmFsdWUubGVuZ3RoID09PSAzLFxuICAgICAgICAnVHJhbnNmb3JtIHdpdGgga2V5IHRyYW5zbGF0ZSBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyIG9yIDMsIGZvdW5kICVzOiAlcycsXG4gICAgICAgIC8qICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSAoPj0wLjg0LjAgc2l0ZT1yZWFjdF9uYXRpdmVfZmIpIFRoaXNcbiAgICAgICAgICogY29tbWVudCBzdXBwcmVzc2VzIGFuIGVycm9yIGZvdW5kIHdoZW4gRmxvdyB2MC44NCB3YXMgZGVwbG95ZWQuIFRvXG4gICAgICAgICAqIHNlZSB0aGUgZXJyb3IsIGRlbGV0ZSB0aGlzIGNvbW1lbnQgYW5kIHJ1biBGbG93LiAqL1xuICAgICAgICB2YWx1ZS5sZW5ndGgsXG4gICAgICAgIHN0cmluZ2lmeVNhZmUodHJhbnNmb3JtYXRpb24pLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JvdGF0ZVgnOlxuICAgIGNhc2UgJ3JvdGF0ZVknOlxuICAgIGNhc2UgJ3JvdGF0ZVonOlxuICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgY2FzZSAnc2tld1gnOlxuICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICAgICAgJ1RyYW5zZm9ybSB3aXRoIGtleSBvZiBcIiVzXCIgbXVzdCBiZSBhIHN0cmluZzogJXMnLFxuICAgICAgICBrZXksXG4gICAgICAgIHN0cmluZ2lmeVNhZmUodHJhbnNmb3JtYXRpb24pLFxuICAgICAgKTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdmFsdWUuaW5kZXhPZignZGVnJykgPiAtMSB8fCB2YWx1ZS5pbmRleE9mKCdyYWQnKSA+IC0xLFxuICAgICAgICAnUm90YXRlIHRyYW5zZm9ybSBtdXN0IGJlIGV4cHJlc3NlZCBpbiBkZWdyZWVzIChkZWcpIG9yIHJhZGlhbnMgJyArXG4gICAgICAgICAgJyhyYWQpOiAlcycsXG4gICAgICAgIHN0cmluZ2lmeVNhZmUodHJhbnNmb3JtYXRpb24pLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BlcnNwZWN0aXZlJzpcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgJ1RyYW5zZm9ybSB3aXRoIGtleSBvZiBcIiVzXCIgbXVzdCBiZSBhIG51bWJlcjogJXMnLFxuICAgICAgICBrZXksXG4gICAgICAgIHN0cmluZ2lmeVNhZmUodHJhbnNmb3JtYXRpb24pLFxuICAgICAgKTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdmFsdWUgIT09IDAsXG4gICAgICAgICdUcmFuc2Zvcm0gd2l0aCBrZXkgb2YgXCIlc1wiIGNhbm5vdCBiZSB6ZXJvOiAlcycsXG4gICAgICAgIGtleSxcbiAgICAgICAgc3RyaW5naWZ5U2FmZSh0cmFuc2Zvcm1hdGlvbiksXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndHJhbnNsYXRlWCc6XG4gICAgY2FzZSAndHJhbnNsYXRlWSc6XG4gICAgY2FzZSAnc2NhbGUnOlxuICAgIGNhc2UgJ3NjYWxlWCc6XG4gICAgY2FzZSAnc2NhbGVZJzpcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgJ1RyYW5zZm9ybSB3aXRoIGtleSBvZiBcIiVzXCIgbXVzdCBiZSBhIG51bWJlcjogJXMnLFxuICAgICAgICBrZXksXG4gICAgICAgIHN0cmluZ2lmeVNhZmUodHJhbnNmb3JtYXRpb24pLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnSW52YWxpZCB0cmFuc2Zvcm0gJXM6ICVzJyxcbiAgICAgICAga2V5LFxuICAgICAgICBzdHJpbmdpZnlTYWZlKHRyYW5zZm9ybWF0aW9uKSxcbiAgICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzVHJhbnNmb3JtO1xuIl0sIm1hcHBp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